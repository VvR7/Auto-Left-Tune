## 引言
### 编写目的
本软件设计文档旨在全面、系统地描述 AutoLeftPiano 的功能需求、架构设计、模块划分及实现细节，为开发团队提供统一的技术规范和参考依据，确保项目各阶段（需求分析、设计、实现、测试、部署）有序推进。同时，本文件也将指导后续维护和二次开发，保证系统的可扩展性与可维护性。
### 读者对象
- **项目负责人**：把握项目进度、资源调度与整体质量管控。  
- **开发者**：理解系统架构、模块接口、技术选型和实现细节。  
- **测试人员**：根据设计文档制定测试用例，验证系统功能与性能是否满足需求。  
- **运维人员**：了解部署流程、运行环境及故障排查要点。  
- **维护人员**：快速上手系统结构及各模块逻辑，便于功能扩展或缺陷修复。
### 软件系统概述
AutoLeftPiano 是一个基于 Flask 的跨平台（Windows、Linux）Web 应用，主要完成用户上传仅含右手主旋律的 MIDI 文件，并自动生成包含左手伴奏的完整钢琴谱及对应 MIDI。系统集成以下主要功能模块：
1. **虚拟钢琴演奏**  
   - 基于 Tone.js 和现实钢琴采样音色，实现鼠标点击演奏。  

2. **MIDI 文件处理**  
   - 拖放/选择上传，上传进度反馈，调用 AI 模型生成左手伴奏。  

3. **PDF 查看与下载**  
   - 利用 PDF.js 显示原始与转换后乐谱，并支持展开/折叠及下载。  

4. **MIDI 播放器**  
   - 播放/暂停/停止、进度条、音量与时间显示，支持对比播放。

后端采用 Flask 蓝图架构，前端使用模块化 ES6 JavaScript，并引入 Tone.js、PDF.js 等第三方库；乐谱生成依赖 MuseScore CLI 将 MIDI 转换为 PDF。
### 文档概述
本设计文档按照项目生命周期和功能模块划分为以下几个主要部分：

1. **引言**  
   包括编写目的、读者对象、系统概述与术语定义，帮助各参与方快速了解 AutoLeftPiano 的背景与定位。

2. **软件设计的约束与依赖**  
   列出技术栈一致性、跨平台兼容性、性能与资源限制、安全性及权限控制、第三方工具版本依赖与开源许可合规等方面的设计约束与依赖关系。

3. **软件设计方案**  
   3.1 **体系结构设计**：说明三层架构（Presentation–Application–Data）及异步任务队列的整体布局；  
   3.2 **用户界面设计**：描述首页、上传页、结果页、历史记录页等主要页面的布局与交互；  
   3.3 **用例设计**：定义关键用例（上传 MIDI、生成伴奏、查看结果、虚拟演奏、文件下载）的参与者、前置条件、流程与异常处理；  
   3.4 **子系统/构件设计**：划分前端组件（虚拟钢琴、上传器、PDF 查看器、播放器）、后端 Blueprint 和服务、模型推理与存储子系统；  
   3.5 **类设计**：列出核心服务类（UploadService、AccompanimentService、PdfService 等）及控制器与数据模型；  
   3.6 **数据设计**：定义关系型数据库表（files、tasks 等）字段及可选缓存方案；  
   3.7 **部署设计**：说明服务器环境、Gunicorn+Nginx、Celery Worker、CI/CD 流程与监控方案。

4. **实施指南**  
   指导运维和开发团队完成环境准备、代码部署、数据库初始化、服务启动、日常运维及故障排查，确保系统平稳上线和持续运行。
### 定义
|术语    |   定义    |
|--------|-----------|
|AutoLeftPiano|本项目的软件名称，用于自动生成钢琴左手伴奏并集成播放与展示功能的 Web 系统|
|MIDI|Musical Instrument Digital Interface，一种用于存储和传输音乐演奏数据的文件格式|
|AI模型|用于自动生成左手伴奏部分的机器学习模型，基于已训练的数据进行推理|
|MuseScore CLI|MuseScore 软件提供的命令行接口，用于将 MIDI 转换为可视化钢琴谱（PDF）等处理|
|Flask|Python 语言的轻量级 Web 应用框架，用于后端服务搭建|
|Blueprint|Flask 的模块化开发机制，用于组织项目中的路由逻辑和功能模块|
|Tone.js|JavaScript 库，用于处理音频播放、合成和调度，实现虚拟钢琴的交互演奏|
|PDF.js|用于在 Web 页面中渲染和浏览 PDF 文件的 JavaScript 库|
|虚拟钢琴界面|Web 页面中实现的可点击式钢琴键盘，用于播放音符音效|
|转换后的MIDI文件|指通过 AI 模型生成包含左手伴奏的完整钢琴 MIDI 文件|
|交互式钢琴演奏|用户通过鼠标点击网页上的琴键，实现钢琴音符播放的功能|

## 软件设计约束与原则
### 软件设计约束
1. **技术栈一致性**  
   - 后端必须使用 Python Flask 框架及其官方推荐的扩展；  
   - 前端统一采用 ES6+ JavaScript、HTML5、CSS3，不引入大型框架（如 React、Vue）。  
2. **跨平台兼容性**  
   - 应同时支持 Windows 和 Linux 服务器部署，文件路径与依赖管理需兼顾两种操作系统差异；  
   - 前端需兼容主流浏览器（Chrome、Firefox、Edge、Safari）近期两个版本。  
3. **性能与资源限制**  
   - 单个 MIDI 文件处理（AI 伴奏生成 + PDF 转换）端到端耗时不超过 15 秒；  
   - 单台服务器峰值并发处理不得超过 20 个请求，CPU 利用率不超 70%，内存占用不超 2GB。  
4. **安全性与权限控制**  
   - 文件上传大小不得超过 10MB，严格校验文件类型（仅限标准 MIDI）；  
   - 上传文件隔离存储，避免路径穿越和任意文件读取；  
   - 所有接口需进行 CSRF 和 XSS 防护。  
5. **第三方工具依赖**  
   - 使用 MuseScore CLI 进行 MIDI→PDF 转换，版本固定为 4.4.2 以保证命令行参数一致；  
   - Tone.js 与 PDF.js 版本需锁定在项目初始化时确定的稳定版本。  
6. **开源许可合规**  
   - 前端所用第三方库必须是 MIT、Apache-2.0 等宽松许可；  
   - 后端所用 Python 库许可需与项目整体许可（例如 MIT）兼容。
### 软件设计原则
1. **高内聚、低耦合**  
   - 各功能模块（路由、文件处理、AI 调用、PDF 渲染、播放器）职责单一，接口清晰；  
   - 通过 Flask Blueprint 和统一的 Service 层解耦业务逻辑与路由控制。  
2. **单一职责（SRP）**  
   - 每个函数/类只负责一个功能，避免“大而全”的工具类；  
   - 例如：文件上传与进度反馈由 UploadService，MIDI 转换由 MidiProcessingService。  
3. **可扩展性（Open–Closed Principle）**  
   - 在不修改现有代码的前提下，可通过配置或继承新增 AI 模型或音色采样；  
   - 插件化设计：后续可增加新乐器伴奏模块。  
4. **可维护性与可测试性**  
   - 编写单元测试覆盖关键逻辑（文件校验、AI 调用、PDF 生成）；  
   - 代码风格统一，遵循 PEP8（后端）与 Airbnb JavaScript Style Guide（前端）。  
5. **性能优先与渐进优化**  
   - 先以功能正确性为核心，再通过缓存（如 Redis）、异步任务（如 Celery）等技术进行性能优化；  
   - 上传/处理任务可考虑队列化，避免长时间阻塞请求。  
6. **用户体验优先**  
   - 前端操作流程清晰、反馈及时；  
   - 虚拟钢琴响应延迟≤50ms，进度条与提示信息准确、易理解。  
7. **安全优先**  
   - 全面采用输入校验、输出编码、防范常见 Web 攻击；  
   - 敏感配置和密钥使用环境变量管理，不硬编码。 

## 软件设计方案
### 体系结构设计
### 用户界面设计
1. **首页（Dashboard）**  
   - 虚拟钢琴：键盘响应点击，支持键盘映射。  
   - 导航栏：上传 MIDI、查看历史文件、切换主题。  
2. **MIDI 上传页**  
   - 拖放/选择文件区域，实时上传进度条。  
   - “生成伴奏”按钮禁用/启用状态切换。  
3. **结果展示页**  
   - 左侧嵌入 PDF.js 查看器（原始 & 生成 PDF 切换）。  
   - 右侧 MIDI 播放器：播放/暂停/停止、进度条、音量控制。  
   - “下载 MIDI”、“下载 PDF”按钮。  
### 用例设计
| 用例 ID | 用例名称           | 主要参与者       | 前置条件                       | 触发事件           | 正常流程                                                                 | 扩展/异常流程                       |
| ------- | ------------------ | ---------------- | ------------------------------ | ------------------ | ------------------------------------------------------------------------ | ---------------------------------- |
| UC-01   | 上传 MIDI 文件     | 注册用户/游客    | 用户已打开上传页               | 点击“上传”按钮     | 1. 用户选择文件<br>2. 系统校验格式<br>3. 文件入队，上传进度显示           | 文件过大／类型不符 → 显示错误提示   |
| UC-02   | 生成左手伴奏       | 注册用户/游客    | 文件上传成功                   | 上传完成后自动触发 | 1. 后端创建异步任务<br>2. 调用 AI 模型生成左手伴奏<br>3. 生成 MIDI & PDF     | 模型推理失败 → 标记任务为“失败”     |
| UC-03   | 查看生成结果       | 注册用户/游客    | UC-02 成功完成                 | 用户点击“查看结果” | 1. 前端请求结果<br>2. PDF.js 加载生成乐谱<br>3. MIDI 播放器就绪             | 文件找不到 → 提示“文件损坏”         |
| UC-04   | 演奏虚拟钢琴       | 所有用户         | 页面加载完成                   | 鼠标点击琴键       | Tone.js 播放对应采样音                                                         |
| UC-05   | 下载文件           | 注册用户/游客    | UC-02/UC-03 完成               | 点击“下载”按钮     | 系统返回对应 PDF 或 MIDI 二进制流                                          |
### 子系统/构件设计
1. **前端子系统**  
   - `PianoComponent`：虚拟钢琴；  
   - `UploaderComponent`：文件拖放与进度；  
   - `PdfViewerComponent`：PDF.js 集成；  
   - `MidiPlayerComponent`：MIDI 控制。  
2. **后端子系统**  
   - **API 层（Blueprints）**：`upload_bp`, `process_bp`, `download_bp`。  
   - **服务层（Services）**：`UploadService`, `AccompanimentService`, `PdfService`, `PlaybackService`。  
   - **任务队列**：Celery Worker；  
   - **模型服务**：加载 AI 模型，提供推理接口。  
3. **存储子系统**  
   - **关系型数据库**：SQLAlchemy ORM 管理文件元数据、任务状态。  
   - **文件存储**：本地目录或 Amazon S3（可选）。  
4. **集成子系统**  
   - **MuseScore CLI**：MIDI→PDF 批处理。  
   - **Tone.js & PDF.js**：前端音频与文档渲染。
### 类设计

### 数据设计
### 部署设计
1.**基础环境**
- 操作系统: Ubuntu20.04+  Windows10+
- Python 3.9+
- Node.js 16+
- 浏览器: Chrome,Edge等主流浏览器
## 实施指南
以下实施指南旨在帮助运维工程师和开发团队快速搭建、配置并上线 AutoLeftPiano 系统，确保在生产环境中稳定运行。

### 1.环境准备
### 2.代码部署
### 3.启动服务