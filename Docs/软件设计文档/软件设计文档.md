## 引言
### 编写目的
本软件设计文档旨在全面、系统地描述 AutoLeftPiano 的功能需求、架构设计、模块划分及实现细节，为开发团队提供统一的技术规范和参考依据，确保项目各阶段（需求分析、设计、实现、测试、部署）有序推进。同时，本文件也将指导后续维护和二次开发，保证系统的可扩展性与可维护性。
### 读者对象
- **项目负责人**：把握项目进度、资源调度与整体质量管控。  
- **开发者**：理解系统架构、模块接口、技术选型和实现细节。  
- **测试人员**：根据设计文档制定测试用例，验证系统功能与性能是否满足需求。  
- **运维人员**：了解部署流程、运行环境及故障排查要点。  
- **维护人员**：快速上手系统结构及各模块逻辑，便于功能扩展或缺陷修复。
### 软件系统概述
AutoLeftPiano 是一个基于 Flask 的跨平台（Windows、Linux）Web 应用，主要完成用户上传仅含右手主旋律的 MIDI 文件，并自动生成包含左手伴奏的完整钢琴谱及对应 MIDI。系统集成以下主要功能模块：
1. **虚拟钢琴演奏**  
   - 基于 Tone.js 和现实钢琴采样音色，实现鼠标点击演奏。  

2. **MIDI 文件处理**  
   - 拖放/选择上传，上传进度反馈，调用 AI 模型生成左手伴奏。  

3. **PDF 查看与下载**  
   - 利用 PDF.js 显示原始与转换后乐谱，并支持展开/折叠及下载。  

4. **MIDI 播放器**  
   - 播放/暂停/停止、进度条、音量与时间显示，支持对比播放。

后端采用 Flask 蓝图架构，前端使用模块化 ES6 JavaScript，并引入 Tone.js、PDF.js 等第三方库；乐谱生成依赖 MuseScore CLI 将 MIDI 转换为 PDF。
### 文档概述
本设计文档按照项目生命周期和功能模块划分为以下几个主要部分：

1. **引言**  
   包括编写目的、读者对象、系统概述与术语定义，帮助各参与方快速了解 AutoLeftPiano 的背景与定位。

2. **软件设计的约束与依赖**  
   列出技术栈一致性、跨平台兼容性、性能与资源限制、安全性及权限控制、第三方工具版本依赖与开源许可合规等方面的设计约束与依赖关系。

3. **软件设计方案**  
   3.1 **体系结构设计**：说明三层架构（Presentation–Application–Data）及异步任务队列的整体布局；  
   3.2 **用户界面设计**：描述首页、上传页、结果页、历史记录页等主要页面的布局与交互；  
   3.3 **用例设计**：定义关键用例（上传 MIDI、生成伴奏、查看结果、虚拟演奏、文件下载）的参与者、前置条件、流程与异常处理；  
   3.4 **子系统/构件设计**：划分前端组件（虚拟钢琴、上传器、PDF 查看器、播放器）、后端 Blueprint 和服务、模型推理与存储子系统；  
   3.5 **类设计**：列出核心服务类（UploadService、AccompanimentService、PdfService 等）及控制器与数据模型；  
   3.6 **数据设计**：定义关系型数据库表（files、tasks 等）字段及可选缓存方案；  
   3.7 **部署设计**：说明服务器环境、Gunicorn+Nginx、Celery Worker、CI/CD 流程与监控方案。

4. **实施指南**  
   指导运维和开发团队完成环境准备、代码部署、数据库初始化、服务启动、日常运维及故障排查，确保系统平稳上线和持续运行。
### 定义
|术语    |   定义    |
|--------|-----------|
|AutoLeftPiano|本项目的软件名称，用于自动生成钢琴左手伴奏并集成播放与展示功能的 Web 系统|
|MIDI|Musical Instrument Digital Interface，一种用于存储和传输音乐演奏数据的文件格式|
|AI模型|用于自动生成左手伴奏部分的机器学习模型，基于已训练的数据进行推理|
|MuseScore CLI|MuseScore 软件提供的命令行接口，用于将 MIDI 转换为可视化钢琴谱（PDF）等处理|
|Flask|Python 语言的轻量级 Web 应用框架，用于后端服务搭建|
|Blueprint|Flask 的模块化开发机制，用于组织项目中的路由逻辑和功能模块|
|Tone.js|JavaScript 库，用于处理音频播放、合成和调度，实现虚拟钢琴的交互演奏|
|PDF.js|用于在 Web 页面中渲染和浏览 PDF 文件的 JavaScript 库|
|虚拟钢琴界面|Web 页面中实现的可点击式钢琴键盘，用于播放音符音效|
|转换后的MIDI文件|指通过 AI 模型生成包含左手伴奏的完整钢琴 MIDI 文件|
|交互式钢琴演奏|用户通过鼠标点击网页上的琴键，实现钢琴音符播放的功能|

## 软件设计约束与原则
### 软件设计约束
1. **技术栈一致性**  
   - 后端必须使用 Python Flask 框架及其官方推荐的扩展；  
   - 前端统一采用 ES6+ JavaScript、HTML5、CSS3，不引入大型框架（如 React、Vue）。  
2. **跨平台兼容性**  
   - 应同时支持 Windows 和 Linux 服务器部署，文件路径与依赖管理需兼顾两种操作系统差异；  
   - 前端需兼容主流浏览器（Chrome、Firefox、Edge、Safari）近期两个版本。  
3. **性能与资源限制**  
   - 单个 MIDI 文件处理（AI 伴奏生成 + PDF 转换）端到端耗时不超过 15 秒；  
   - 单台服务器峰值并发处理不得超过 20 个请求，CPU 利用率不超 70%，内存占用不超 2GB。  
4. **安全性与权限控制**  
   - 文件上传大小不得超过 10MB，严格校验文件类型（仅限标准 MIDI）；  
   - 上传文件隔离存储，避免路径穿越和任意文件读取；  
   - 所有接口需进行 CSRF 和 XSS 防护。  
5. **第三方工具依赖**  
   - 使用 MuseScore CLI 进行 MIDI→PDF 转换，版本固定为 4.4.2 以保证命令行参数一致；  
   - Tone.js 与 PDF.js 版本需锁定在项目初始化时确定的稳定版本。  
6. **开源许可合规**  
   - 前端所用第三方库必须是 MIT、Apache-2.0 等宽松许可；  
   - 后端所用 Python 库许可需与项目整体许可（例如 MIT）兼容。
### 软件设计原则
1. **高内聚、低耦合**  
   - 各功能模块（路由、文件处理、AI 调用、PDF 渲染、播放器）职责单一，接口清晰；  
   - 通过 Flask Blueprint 和统一的 Service 层解耦业务逻辑与路由控制。  
2. **单一职责（SRP）**  
   - 每个函数/类只负责一个功能，避免“大而全”的工具类；  
   - 例如：文件上传与进度反馈由 UploadService，MIDI 转换由 MidiProcessingService。  
3. **可扩展性（Open–Closed Principle）**  
   - 在不修改现有代码的前提下，可通过配置或继承新增 AI 模型或音色采样；  
   - 插件化设计：后续可增加新乐器伴奏模块。  
4. **可维护性与可测试性**  
   - 编写单元测试覆盖关键逻辑（文件校验、AI 调用、PDF 生成）；  
   - 代码风格统一，遵循 PEP8（后端）与 Airbnb JavaScript Style Guide（前端）。  
5. **性能优先与渐进优化**  
   - 先以功能正确性为核心，再通过缓存（如 Redis）、异步任务（如 Celery）等技术进行性能优化；  
   - 上传/处理任务可考虑队列化，避免长时间阻塞请求。  
6. **用户体验优先**  
   - 前端操作流程清晰、反馈及时；  
   - 虚拟钢琴响应延迟≤50ms，进度条与提示信息准确、易理解。  
7. **安全优先**  
   - 全面采用输入校验、输出编码、防范常见 Web 攻击；  
   - 敏感配置和密钥使用环境变量管理，不硬编码。 

## 软件设计方案
### 体系结构设计
### 用户界面设计
1. **首页（Dashboard）**  
   - 虚拟钢琴：键盘响应点击，支持键盘映射。  
   - 导航栏：上传 MIDI、查看历史文件、切换主题。  
2. **MIDI 上传页**  
   - 拖放/选择文件区域，实时上传进度条。  
   - “生成伴奏”按钮禁用/启用状态切换。  
3. **结果展示页**  
   - 左侧嵌入 PDF.js 查看器（原始 & 生成 PDF 切换）。  
   - 右侧 MIDI 播放器：播放/暂停/停止、进度条、音量控制。  
   - “下载 MIDI”、“下载 PDF”按钮。  
### 用例设计
| 用例 ID | 用例名称           | 主要参与者       | 前置条件                       | 触发事件           | 正常流程                                                                 | 扩展/异常流程                       |
| ------- | ------------------ | ---------------- | ------------------------------ | ------------------ | ------------------------------------------------------------------------ | ---------------------------------- |
| UC-01   | 上传 MIDI 文件     | 注册用户/游客    | 用户已打开上传页               | 点击“上传”按钮     | 1. 用户选择文件<br>2. 系统校验格式<br>3. 文件入队，上传进度显示           | 文件过大／类型不符 → 显示错误提示   |
| UC-02   | 生成左手伴奏       | 注册用户/游客    | 文件上传成功                   | 上传完成后自动触发 | 1. 后端创建异步任务<br>2. 调用 AI 模型生成左手伴奏<br>3. 生成 MIDI & PDF     | 模型推理失败 → 标记任务为“失败”     |
| UC-03   | 查看生成结果       | 注册用户/游客    | UC-02 成功完成                 | 用户点击“查看结果” | 1. 前端请求结果<br>2. PDF.js 加载生成乐谱<br>3. MIDI 播放器就绪             | 文件找不到 → 提示“文件损坏”         |
| UC-04   | 演奏虚拟钢琴       | 所有用户         | 页面加载完成                   | 鼠标点击琴键       | Tone.js 播放对应采样音                                                         |
| UC-05   | 下载文件           | 注册用户/游客    | UC-02/UC-03 完成               | 点击“下载”按钮     | 系统返回对应 PDF 或 MIDI 二进制流                                          |
### 子系统/构件设计

AutoLeftPiano 采用分层架构设计，主要分为前端展示层、后端应用层、数据管理层和外部集成层四个部分：

#### 1. 前端展示层（Frontend Components）

**1.1 虚拟钢琴组件（Piano Component）**
- **文件**：`static/js/piano.js`
- **职责**：实现交互式虚拟钢琴界面，支持鼠标点击演奏和键盘映射
- **核心功能**：
  - 钢琴键盘渲染（88键布局）
  - 音符播放（基于 Tone.js + SampleLibrary）
  - 键盘事件绑定（QWERTY 键盘映射）
  - 视觉反馈效果（按键动画）
  - 音符记录功能（支持 MIDI 生成）
- **依赖**：Tone.js、SampleLibrary.js、钢琴采样音色文件

**1.2 MIDI 播放器组件（MidiPlayer Component）**
- **文件**：`static/js/midiPlayer.js`
- **职责**：播放 MIDI 文件并提供音频控制功能
- **核心功能**：
  - MIDI 文件解析和播放
  - 播放控制（播放/暂停/停止/跳转）
  - 音量控制和进度显示
  - 支持原始和转换后文件对比播放
  - 钢琴键盘视觉同步显示
- **依赖**：Tone.js、jsmidgen.js（MIDI 解析）、SampleLibrary.js

**1.3 PDF 查看器组件（PdfViewer Component）**
- **文件**：`static/js/pdfViewer.js`
- **职责**：在线查看生成的钢琴乐谱 PDF 文件
- **核心功能**：
  - PDF 文件加载和渲染
  - 多页面显示和缩放适配
  - 资源管理和内存优化
  - 加载进度显示
- **依赖**：PDF.js (CDN)

**1.4 文件上传组件（Upload Component）**
- **文件**：`static/js/main.js` 中的上传模块
- **职责**：处理 MIDI 文件的拖放上传和进度显示
- **核心功能**：
  - 拖拽上传界面
  - 文件格式验证（仅限 .mid）
  - 上传进度反馈
  - 文件名中文字符检查
- **依赖**：原生 JavaScript File API

**1.5 用户界面组件（UI Components）**
- **文件**：`templates/index.html`, `templates/MidiEditor.html`
- **职责**：提供统一的用户界面布局和交互
- **核心功能**：
  - 响应式页面布局
  - 导航和页面切换
  - 状态提示和错误处理
  - 主题和样式管理

#### 2. 后端应用层（Backend Application Layer）

**2.1 路由控制层（Blueprint Layer）**
- **文件**：`routes/main.py`
- **Blueprint**：`main` - 主要业务路由
- **职责**：接收 HTTP 请求，调用业务服务，返回响应
- **API 端点**：
  - `GET /` - 首页渲染
  - `GET /MidiEditor` - MIDI 编辑器页面
  - `POST /upload` - MIDI 文件上传
  - `GET /convert-to-pdf/<session_id>` - PDF 转换
  - `GET /download/<file_type>/<session_id>` - 文件下载
  - `GET /view-pdf/<session_id>` - PDF 在线查看
  - `GET /session/<session_id>` - 会话状态查询

**2.2 业务服务层（Service Layer）**

**(a) MIDI 处理服务（Transform Service）**
- **文件**：`utils/transform.py`
- **职责**：MIDI 文件处理和格式转换
- **核心功能**：
  - `split_midi()` - MIDI 文件处理（目前实现为直接复制，预留 AI 伴奏生成接口）
  - `export_pdf()` - MIDI 转 PDF 格式转换
  - `find_musescore_executable()` - 跨平台 MuseScore 路径管理
- **依赖**：MuseScore CLI

**(b) 会话管理服务（Session Service）**
- **文件**：`models/session.py`
- **职责**：管理用户会话和文件状态
- **核心功能**：
  - 单例模式会话管理器
  - 会话数据持久化（JSON 文件）
  - 文件路径和状态跟踪
- **数据结构**：
  ```python
  session_data = {
      'original_filename': str,    # 原始文件名
      'input_path': str,          # 上传文件路径
      'output_midi_path': str,    # 处理后 MIDI 路径
      'output_pdf_path': str,     # 生成的 PDF 路径
      'original_pdf_path': str    # 原始 MIDI 的 PDF 路径
  }
  ```

**2.3 配置管理层（Configuration Layer）**
- **文件**：`config/config.py`
- **职责**：统一管理系统配置和路径
- **配置项**：
  - 文件存储路径（上传、输出目录）
  - 静态资源和模板路径
  - MuseScore 可执行文件路径（Windows/Linux）
  - 会话数据文件路径

#### 3. 数据管理层（Data Management Layer）

**3.1 文件存储系统（File Storage System）**
- **上传目录**：`app/files/uploads/` - 存储用户上传的原始 MIDI 文件
- **输出目录**：`app/files/outputs/` - 存储处理后的 MIDI 和生成的 PDF 文件
- **命名规则**：
  - 上传文件：`{session_id}_{original_filename}`
  - 输出 MIDI：`{session_id}_output.mid`
  - 输出 PDF：`{session_id}_output.pdf`
  - 原始 PDF：`original_{session_id}.pdf`

**3.2 会话数据存储（Session Data Storage）**
- **存储方式**：JSON 文件 (`app/files/session_data.json`)
- **数据结构**：键值对映射（session_id → session_data）
- **特点**：内存缓存 + 文件持久化，单例模式保证数据一致性

#### 4. 外部集成层（External Integration Layer）

**4.1 MuseScore CLI 集成**
- **用途**：MIDI 文件转换为可视化钢琴谱 PDF
- **跨平台支持**：
  - Windows：`utils/MuseScoreWindows/bin/MuseScore4.exe`
  - Linux：`utils/MuseScoreLinux/bin/mscore4portable`
- **调用方式**：subprocess 模块执行命令行转换

**4.2 第三方 JavaScript 库集成**
- **Tone.js**：Web Audio API 封装，提供音频合成和播放能力
- **PDF.js**：Mozilla 开发的 PDF 渲染库，支持在线 PDF 查看
- **jsmidgen.js**：MIDI 文件解析和生成库
- **SampleLibrary.js**：钢琴采样音色库，提供高质量音色

**4.3 预留 AI 模型集成接口**
- **设计位置**：`utils/transform.py` 的 `split_midi()` 函数
- **预期功能**：调用机器学习模型自动生成左手伴奏
- **当前状态**：简单的文件复制操作，为后续 AI 集成预留接口

#### 5. 子系统交互流程

**5.1 文件上传处理流程**
1. 前端上传组件验证文件格式和文件名
2. 后端路由接收文件，生成唯一 session_id
3. 会话管理服务创建会话记录
4. MIDI 处理服务进行文件处理
5. MuseScore CLI 生成 PDF 文件
6. 返回处理结果给前端

**5.2 文件播放查看流程**
1. 前端通过 session_id 请求文件状态
2. 后端验证会话有效性
3. PDF 查看器组件加载并渲染 PDF
4. MIDI 播放器组件加载并播放音频
5. 虚拟钢琴组件同步显示演奏效果

**5.3 跨平台部署适配**
- 配置管理层自动检测操作系统类型
- 动态选择对应平台的 MuseScore 可执行文件
- 文件路径使用 `os.path.join()` 保证跨平台兼容性
### 类设计

AutoLeftPiano 系统的类设计遵循面向对象设计原则，实现高内聚、低耦合的模块化架构。

#### 1. 后端核心服务类

**1.1 会话管理类（SessionManager）**
```python
class SessionManager:
    """
    会话管理器 - 单例模式
    负责管理用户会话数据和文件状态跟踪
    """
    _instance = None
    _session_data = {}
    
    def __new__(cls) -> 'SessionManager'
    def _load_session_data(self) -> None
    def save_session_data(self) -> None
    def get_session(self, session_id: str) -> dict
    def create_session(self, session_id: str, data: dict) -> None
    def session_exists(self, session_id: str) -> bool
    
    # 属性：
    # - _instance: 单例实例
    # - _session_data: 内存中的会话数据缓存
```

**1.2 MIDI 处理服务类（TransformService）**
```python
class TransformService:
    """
    MIDI 文件处理服务
    提供 MIDI 文件转换和 PDF 生成功能
    """
    @staticmethod
    def find_musescore_executable() -> str
    
    @staticmethod
    def split_midi(input_file: str, output_file: str, 
                   musescore_path: str = None) -> bool
    
    @staticmethod
    def export_pdf(input_file: str, output_file: str, 
                   musescore_path: str = None) -> bool
    
    # 功能：
    # - 跨平台 MuseScore 路径管理
    # - MIDI 文件处理（预留 AI 接口）
    # - MIDI 转 PDF 格式转换
```

**1.3 配置管理类（Config）**
```python
class Config:
    """
    系统配置管理类
    统一管理应用配置和路径设置
    """
    # 类属性 - 路径配置
    BASE_DIR: str
    APP_DIR: str
    UPLOAD_FOLDER: str
    OUTPUT_FOLDER: str
    SESSION_FILE: str
    STATIC_FOLDER: str
    TEMPLATE_FOLDER: str
    MUSESCORE_PATH_WINDOWS: str
    MUSESCORE_PATH_LINUX: str
    
    @staticmethod
    def init_app() -> None
    
    # 功能：
    # - 目录路径管理
    # - 应用初始化配置
    # - 跨平台路径适配
```

**1.4 路由控制类（Blueprint Integration）**
```python
# 虽然使用 Flask Blueprint，但可以抽象为控制器类
class MainController:
    """
    主要业务控制器
    处理 HTTP 请求和响应
    """
    def __init__(self):
        self.session_manager = SessionManager()
    
    def index(self) -> Response                    # GET /
    def midi_editor(self) -> Response             # GET /MidiEditor  
    def upload_file(self) -> Response             # POST /upload
    def convert_to_pdf(self, session_id: str) -> Response
    def download_file(self, file_type: str, session_id: str) -> Response
    def get_session(self, session_id: str) -> Response
    def view_pdf(self, session_id: str) -> Response
    def export_original_pdf(self, session_id: str) -> Response
    def view_original_pdf(self, session_id: str) -> Response
    def download_original_pdf(self, session_id: str) -> Response
    def download_original_midi(self, session_id: str) -> Response
    
    # 私有方法：
    def _contains_chinese(self, text: str) -> bool
```

#### 2. 前端核心组件类

**2.1 虚拟钢琴类（Piano）**
```javascript
class Piano {
    constructor()
    
    // 核心属性
    pianoHTML: string              // 钢琴组件 HTML 模板
    pianoShow: boolean             // 钢琴显示状态
    enableBlackKey: boolean        // 黑键启用状态
    showKeyName: boolean           // 键名显示状态
    showNoteName: boolean          // 音符名显示状态
    synth: Object                  // Tone.js 合成器实例
    audioContextStarted: boolean   // 音频上下文状态
    audioLoaded: boolean          // 音频加载状态
    
    // 初始化方法
    init(element: string|Element): void
    initPiano(): Promise<void>
    startAudioContext(): Promise<void>
    
    // 渲染方法
    computeEleSize(): void
    renderPianoKeys(): void
    updateKeyDisplay(): void
    
    // 交互方法
    bindKeyboardEvent(): void
    clickPianoKey(event: Event, keyCode: string): void
    triggerKeyEffect(key: Element, duration: number): void
    triggerKeyByName(noteName: string, duration: number): void
    
    // 音符处理
    getNoteByKeyCode(keyCode: string): Object
    getNoteByName(name: string): Object
    playNoteByKeyCode(keyCode: string): Promise<void>
    playNote(notename: string, duration: string): Promise<void>
    
    // MIDI 生成功能
    noteStorage(noteName: string): void
    generateMidiFromStorage(): Promise<void>
    clearStoredNotes(): void
    
    // 录制功能
    recordBegin(): void
    
    // UI 状态管理
    showLoadingIndicator(): void
    hideLoadingIndicator(): void
}
```

**2.2 MIDI 播放器类（MidiPlayer）**
```javascript
class MidiPlayer {
    constructor(options: Object)
    
    // 核心属性
    currentMidiData: Object        // 当前 MIDI 数据
    midiNotes: Array              // MIDI 音符序列
    midiStop: boolean             // 停止标志
    isPaused: boolean             // 暂停状态
    audioContext: AudioContext    // 音频上下文
    synth: Object                 // 合成器实例
    volume: number                // 音量设置
    lastPlayedTime: number        // 上次播放时间
    currentFileId: string         // 当前文件标识
    isConvertedFile: boolean      // 是否为转换后文件
    initialized: boolean          // 初始化状态
    
    // 回调函数
    onNotePlay: Function          // 音符播放回调
    onMusicEnd: Function          // 音乐结束回调
    
    // 初始化方法
    initAudio(): boolean
    initSynthesizer(): void
    checkMidiLibrary(): void
    
    // 文件加载
    loadMidiAndPlay(midiUrl: string, isConverted: boolean): void
    loadMidiFileAndPlay(file: File, isConverted: boolean): void
    
    // 播放控制
    playMidi(): void
    playLoop(): void
    playNote(note: Object): void
    stopMidiPlay(): void
    pauseMidiPlay(): void
    resumeMidiPlay(): void
    pauseForSeek(): void
    resumeFromSeek(seekTimeMs: number): void
    
    // 音频设置
    setVolume(volume: number): void
    
    // 状态管理
    resetPlayStatus(): void
    getPlaybackInfo(): Object
    calculateTotalDuration(): number
    
    // 视觉反馈
    triggerPianoKeyVisual(noteName: string, durationMs: number): void
    
    // 工具方法
    isMidiLibAvailable(): boolean
    getMidiLib(): Object
}
```

**2.3 PDF 查看器类（PdfViewer）**
```javascript
class PdfViewer {
    constructor()
    
    // 核心属性
    pdfViewer: HTMLElement         // PDF 查看器容器
    pdfContainer: HTMLElement      // PDF 容器元素
    currentPdfDoc: Object          // 当前 PDF 文档对象
    isLoading: boolean             // 加载状态
    renderTasks: Array             // 渲染任务列表
    
    // 文档管理
    loadPdfFromUrl(url: string): Promise<boolean>
    clearResources(): Promise<void>
    
    // 渲染方法
    renderPage(pageNumber: number): Promise<void>
    
    // 工具方法 (继承自实际实现)
    // - 支持多页面显示
    // - 自动缩放适配
    // - 内存优化管理
}
```

#### 3. 数据模型类

**3.1 会话数据模型（SessionData）**
```python
from typing import Optional
from dataclasses import dataclass

@dataclass
class SessionData:
    """
    会话数据模型
    定义单个会话的数据结构
    """
    session_id: str
    original_filename: str
    input_path: str
    output_midi_path: str
    output_pdf_path: str
    original_pdf_path: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    status: str = "active"  # active, expired, error
    
    def to_dict(self) -> dict
    @classmethod
    def from_dict(cls, data: dict) -> 'SessionData'
    
    def get_file_paths(self) -> dict
    def validate(self) -> bool
```

**3.2 文件信息模型（FileInfo）**
```python
@dataclass
class FileInfo:
    """
    文件信息模型
    描述上传和生成文件的基本信息
    """
    filename: str
    file_path: str
    file_size: int
    file_type: str  # 'midi', 'pdf'
    created_at: str
    is_original: bool = True
    
    def get_file_extension(self) -> str
    def exists(self) -> bool
    def get_size_human_readable(self) -> str
```

#### 4. 工具类和辅助类

**4.1 文件验证类（FileValidator）**
```python
class FileValidator:
    """
    文件验证工具类
    提供文件格式和内容验证功能
    """
    ALLOWED_EXTENSIONS = {'.mid', '.midi'}
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
    
    @staticmethod
    def is_valid_midi_file(file_path: str) -> bool
    
    @staticmethod
    def is_valid_filename(filename: str) -> bool
    
    @staticmethod
    def contains_chinese(text: str) -> bool
    
    @staticmethod
    def get_file_size(file_path: str) -> int
    
    @staticmethod
    def validate_file_content(file_path: str) -> bool
```

**4.2 路径管理类（PathManager）**
```python
class PathManager:
    """
    路径管理工具类
    处理文件路径生成和管理
    """
    @staticmethod
    def generate_session_filename(session_id: str, original_filename: str) -> str
    
    @staticmethod
    def generate_output_paths(session_id: str, original_filename: str) -> dict
    
    @staticmethod
    def ensure_directory_exists(directory_path: str) -> None
    
    @staticmethod
    def clean_old_files(directory_path: str, max_age_hours: int = 24) -> None
    
    @staticmethod
    def get_relative_path(absolute_path: str, base_path: str) -> str
```

### 数据设计

AutoLeftPiano 采用轻量级数据存储设计，主要使用文件系统和 JSON 数据格式，为后续数据库集成预留扩展空间。

#### 1. 会话数据结构

**1.1 会话数据 JSON 格式**
```json
{
  "session_data": {
    "uuid-session-id-1": {
      "original_filename": "example.mid",
      "input_path": "/app/files/uploads/uuid-session-id-1_example.mid",
      "output_midi_path": "/app/files/outputs/uuid-session-id-1_output.mid",
      "output_pdf_path": "/app/files/outputs/uuid-session-id-1_output.pdf",
      "original_pdf_path": "/app/files/outputs/original_uuid-session-id-1.pdf",
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:35:00Z",
      "status": "completed",
      "file_size": 15360,
      "processing_time": 5.2
    },
    "uuid-session-id-2": {
      "original_filename": "music.mid",
      "input_path": "/app/files/uploads/uuid-session-id-2_music.mid",
      "output_midi_path": "/app/files/outputs/uuid-session-id-2_output.mid",
      "output_pdf_path": "/app/files/outputs/uuid-session-id-2_output.pdf",
      "created_at": "2024-01-15T11:00:00Z",
      "status": "processing"
    }
  }
}
```

**1.2 会话数据字段说明**
| 字段名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| original_filename | string | 是 | 用户上传的原始文件名 |
| input_path | string | 是 | 上传文件在服务器的存储路径 |
| output_midi_path | string | 是 | 处理后 MIDI 文件路径 |
| output_pdf_path | string | 是 | 生成的 PDF 文件路径 |
| original_pdf_path | string | 否 | 原始 MIDI 转换的 PDF 路径 |
| created_at | string | 否 | 会话创建时间（ISO 8601 格式）|
| updated_at | string | 否 | 会话最后更新时间 |
| status | string | 否 | 处理状态：pending/processing/completed/error |
| file_size | integer | 否 | 原始文件大小（字节）|
| processing_time | float | 否 | 处理耗时（秒）|

#### 2. 文件存储结构

**2.1 目录组织结构**
```
AutoLeftPiano/app/files/
├── uploads/                          # 用户上传文件目录
│   ├── {session_id}_{filename}.mid
│   └── ...
├── outputs/                          # 处理结果文件目录
│   ├── {session_id}_output.mid       # 处理后的 MIDI 文件
│   ├── {session_id}_output.pdf       # 生成的 PDF 乐谱
│   ├── original_{session_id}.pdf     # 原始 MIDI 的 PDF
│   └── ...
├── temp/                             # 临时文件目录（可选）
│   └── ...
└── session_data.json                 # 会话数据持久化文件
```

**2.2 文件命名规范**
| 文件类型 | 命名格式 | 示例 |
|----------|----------|------|
| 上传文件 | `{session_id}_{original_filename}` | `uuid123_music.mid` |
| 输出 MIDI | `{session_id}_output.mid` | `uuid123_output.mid` |
| 输出 PDF | `{session_id}_output.pdf` | `uuid123_output.pdf` |
| 原始 PDF | `original_{session_id}.pdf` | `original_uuid123.pdf` |

#### 3. 配置数据结构

**3.1 应用配置**
```python
# 系统配置数据结构
APP_CONFIG = {
    'paths': {
        'base_dir': '/path/to/AutoLeftPiano',
        'upload_folder': '/path/to/uploads',
        'output_folder': '/path/to/outputs',
        'static_folder': '/path/to/static',
        'template_folder': '/path/to/templates'
    },
    'file_limits': {
        'max_file_size': 10485760,        # 10MB
        'allowed_extensions': ['.mid', '.midi'],
        'session_timeout': 86400          # 24小时
    },
    'musescore': {
        'windows_path': '/path/to/MuseScore4.exe',
        'linux_path': '/path/to/mscore4portable',
        'timeout': 30                     # 转换超时时间（秒）
    },
    'security': {
        'allowed_origins': ['localhost', '127.0.0.1'],
        'max_requests_per_hour': 100,
        'enable_csrf_protection': True
    }
}
```

#### 4. 前端数据结构

**4.1 钢琴键位映射数据**
```javascript
// 键盘映射配置
const PIANO_KEY_MAPPING = {
  // 白键映射
  white_keys: {
    'KeyA': {note: 'C4', keyCode: 'C4', octave: 4},
    'KeyS': {note: 'D4', keyCode: 'D4', octave: 4},
    'KeyD': {note: 'E4', keyCode: 'E4', octave: 4},
    // ... 更多映射
  },
  // 黑键映射
  black_keys: {
    'KeyW': {note: 'C#4', keyCode: 'CS4', octave: 4},
    'KeyE': {note: 'D#4', keyCode: 'DS4', octave: 4},
    // ... 更多映射
  }
};
```

**4.2 MIDI 播放状态数据**
```javascript
// MIDI 播放器状态数据结构
const PLAYER_STATE = {
  isPlaying: false,
  isPaused: false,
  currentTime: 0,
  duration: 0,
  volume: 0.7,
  currentFile: {
    id: 'session_id',
    name: 'filename.mid',
    isConverted: false,
    url: '/download/midi/session_id'
  },
  playbackInfo: {
    tempo: 120,
    timeSignature: '4/4',
    totalNotes: 150,
    currentNote: 45
  }
};
```


这种数据设计方案既满足当前轻量级应用的需求，又为后续扩展到高并发、大数据量场景提供了清晰的升级路径。
### 部署设计
1.**基础环境**
- 操作系统: Ubuntu20.04+  Windows10+
- Python 3.9+
- Node.js 16+
- 浏览器: Chrome,Edge等主流浏览器
## 实施指南
以下实施指南旨在帮助运维工程师和开发团队快速搭建、配置并上线 AutoLeftPiano 系统，确保在生产环境中稳定运行。

### 1.环境准备
### 2.代码部署
### 3.启动服务